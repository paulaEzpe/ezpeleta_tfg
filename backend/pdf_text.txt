...¿queremos hacer un port de...? y si no se tiene el código fuente porque se perdió, entonces  hay que hacerlo utilizando emulación  Sí, o sea, esto es una forma bonita de llamar la ingeniería inversa, también, a todo esto. Es  coger los binarios y desensamblar, analizar el programa e intentar ver cómo funciona, qué está  haciendo en cada punto e intentar simularlo con un programa de c, c+.... no hay documentación  en estos sistemas  PROBLEMAS LEGALES EN EMULACIÓN??  En general, tenían los procesadores, solían ser de uso general, un motorola, un intel... pero  toda la parte gráfica y de sonido solía ser software propietario que no está documentado y hay  que emularlo  Los problemas legales de los emuladores siempre han estado ahí en una zona gris, ¿no?, de  que no distribuyen las roms. mientras no se distribuya la rom, todo esto es legal.  Arica sacó un juego de tetris y pidió quitarlo de MAME, porque lo recomercializaron y se  comentó la línea y ya está.  BARRERA DE PROTECCIÓN DE LOS JUEGOS:  la mayor barrera es la protección que tenían los juegos porque es una caja negra que no  comentan en ningún sitio y a base de ver que es lo que el juego escribe y que es lo que ve, hay  que intentar averiguar qué es lo que está haciendo internamente.  JUEGO DEL CONEJO VERDE  ¿Cuál era la protección de los rectángulos? La protección era un chip... ...que le pasabas las  coordenadas... ...y te... Lo hacían por hardware. Era un chip... ...con cuatro registros... ...con  cuatro registros.  Entonces, le escribías las coordenadas en coma fija y te devolvía por un bit si había  interceptado o no. Si no lo implementabas, eso se quedaba siempre ahí en el bus al aire, como  que no había intersección. ibas a llegar al juego y no podías matar.  ¿Para qué lo usaban? Para la condición de los golpes.  JUEGO DE LAS VACAS QUE DISPARAN  otro juego de unas vacas que disparan, tenía un DMA que te podía hacer operaciones  aritméticas al transferir datos de un lado a otro de la memoria y lo usaban para mover los  sprites?? ponen el sprite en la posición 00 todos ellos y luego hacían un dma que iban  sumando la posición dondE querían que se colocase, si implementabas el dma normal que  tenia la placa, todos los muñecos estaban todos en la esquina de arriba y no se movian, osea,  el juego funcionaba porque solo era la parte de dibujado, pero no servía para nada. Esto se  sacó a base de ingeniería inversa, viendo que escribía el juego y lo que se quería obtener, se  pudo sacar como funcionaba. Esto no estaba en la placa, sino en un chip custom, que no era realmente un chip a parte, sino  uno de los chips que controlaba el bus directamente solo se dedicaba a activar esto y permitía  hacer de memoria con el dma estas operaciones (22.38).  el neogeo tenía juegos mas famosos y más caros y era muy interesante que no los pudiesen  copiar.  Los primeros juegos eran básicamente roms en una placa que se copiaba la rom y ya podías  hacerlo funcionar. le mandabas una ristra de 1024 bits y te lo reordenaba con un algoritmo que  nadie conoce y los comparaba con determinados patrones para ver si eso coincide con lo que  esperaba o no. nunca comparaba la lista entera para que no supieses lo que esperaba sino que  iba comparando trocitos.  el noseque of fighters era algo más sencillo y lo que hicieron es que en la rom en vez de grabar  las direcciones tal cual desordenaban la dirección, el bit 1 estaba en el 15, el 15 en el 8... Esta  es de las más fácil de romper.  JUEGO CHINO ESTILO NEOGEO  otra protección más gorda es la de un sistema chino que tenía unos juegos estilo neogeo, que  era un hardware que los sprites estaban en un formato que no conocían con nada hasta la  fecha y ejecutando código en la placa original se estuvo viendo que colores se pintaban cuando  se le daba a determinado bit para   ver cómo afectaba cada bit a los colores y ahí descubrieron  que los gráficos en vez de estar sobre una rom, estaban partidos en 2, el canal alfa en una rom  y los colores en la otra, pero solo los colores que eran transparentes, para ahorrar espacio,  porque las roms son muy caras. Esto costó un par de meses y había que grabar las memorias.  Fueron horas con el ultravioleta para que se borrase la memoria.  A parte de lo de la comprensión tenía una protección que tenía un procesador en el cartucho  que era más potente que el propio procesador que tenía la placa del juego. Los últimos juegos  directamente corrían en el cartucho porque era más potente.le mandaban a la placa las  pulsaciones de los botones porque era mucho más eficiente. estos procesadores llevaban una  rom que hacía que arrancase el resto del juego y que sin eso de ahi no se podía saber que  hacia el resto de la rom. lo sacamos a fotos porque si hacías un offset tan grande que se daba  la vuelta la memoria, podías leer la memoria interna. hicieron muchas fotos que mostraba en  pantalla el contenido de memoria. a base de fotos hicieron un programa que ponías toda la  linea y en el último número a la derecha un checksum para ver si lo que has escrito estaba  bien. la b y el 0 se parecen mucho pero tienen diferente color y así consiguieron conseguir  tener el juego funcionando y ya utilizando los puertos del cartucho con un protocolo tenerlos bit  a bit. JUEGO CAPCOM SYSTEM 3  Capcom system 3??? es otro de los sistemas que estaban protegidos y no se podían emular,  tenia 2 protecciones una era que estaba encriptado el código entero y había que desencriptar  con un algoritmo y la otra era que los gráficos eran custom en un formato muy raro con  patrones muy raros en la rom. varios meses veías como escribía capcom y video como  funcionaba escribir eso pudieron ver cómo funcionaba ese sistema, que utilizaba compresión y  que tenía un dma(acceso directo a memoria: si tienes q coger bloques de memoria el  microprocesador tarda mucho porque está haciendo otras cosas pero a esto le dices de tal a tal  lo llevas a esa dirección y va mucho más rápido que si va por procesador) que le pasabas 2  punteros, uno a la tabla de 256b bytes y otro al bloque de datos, que cuando leía, si el primer  bit estaba alto, entonces los siguientes 7 bits eran un índice en la primera tabla, que  completaba 2 bytes a 1, pero además si el segundo estaba alto, los siguientes 6 eran el número  de veces que se repetía el siguiente byte. esto para los gráficos. los gráficos tienen muchos  huecos y por eso no vas a grabar pixel a pixel, entonces utilizaban esto.  PROBLEMAS LEGALES/CLASIFICADOS  otro problema muy gordo es que todo fuese no documentado y que incluso fueran cosas  clasificadas. en el sega model 2, el hardware lo diseñaron para hacer simuladores de vuelo,  entonces el procesador para 3d, era clasificado y no se podía obtener ninguna documentación.  hizo ingeniería inversa para poder sacar esto durante 3 o 4 meses, decodificando para ver qué  es lo que hacía cada cosa. y cuando lo cartoon los personajes estaban boca abajo, porque en  vez de la operación hacia un lado lo hicieron hacia otra. era solo una linea de codigo lo que  estaba mal. corrían código en la placa original y en el emulador veían los resultados y  comparan.  si un juego está para dos placas, los comandos son los mismos, y así con otro juego pudieron  ver que pasaba con otro.  EL FIN DEL TIEMPO (JUEGO DE LA CHICA ESA)  el fin del tiempo: nunca se vio la máquina en realidad. después de 35 años apareció la chica,  para ver si le podían arreglar la máquina, y a cambio se quedaron las roms de la asociación  arcade de Cataluña. algún chip hubo que cambiar. Las roms si son roms no se estropean  porque están cableadas, pero las aprons y las flashes van perdiendo al filtrar corriente en el  transistor y se gastan.  primer problema para el driver de mame:  Problema de código:  el primer problema estaba relacionado con el código. era que existían 18 roms y tenían que  saber cuales de ellas pertenecían a codigo y cuales a gráficos. para abordar este problema se  implementó un enfoque de prueba y error, desensamblando cada rom individualmente y  buscandoo un patron específico de arranque del procesador z80 en la direccion 0, dado que  este procesador siemmmpre debia iniciar en la direccion 0 con una secuencia tpitica, y para ello  se realizaon pruebas de activacion y desactivacion de interrupciones en diferentes ocasiones. Gracias a esto se identificaron patrones específicos en las rom y poder establecer orden y  lógica en ellas.  Segundo problema PROBLEMA DE GRÁFICOS  el segundo probema era que de las 10 roms de gráficos, 9 de ellas formaban un bloque  coherente, pero la décima estaba separada. mediante la modificacion de bits en una de las 9,  se descubrió que contenía gráficos de 1 bit, representando un abecedario rotado. La  complejidad radica en que el juego original tenia una orientacion vertical, intercambiando las  coordendas x e y. se identificó que los grñaficos de 1 bit estaban organizados en ternas. La rom  separada también tenía gráficos de un bit.  Cargamos en MAME, pero no hemos metido gráficos ni hemos metido nada. O sea, lo está  escribiendo el que se está leyendo de cada dirección de memoria. Esto es ya la parte de  Ingeniería Inversa total. Y ver en IDA qué es lo que estaba haciendo. Y de ahí, pues en IDA,  como se puede ir metiendo comentarios, para no olvidarnos de qué es lo que estaba haciendo  cada parte, iba metiendo comentarios de qué es lo que hacía cada cosa, lo que yo me  imaginaba, ponía nombres a las funciones, pensando en que esto es lo que va a hacer. Para el  coprocesador de la ITONA no había desensamblado el procesador, por lo cual yo tenía un  notepad y escribía ahí en el notepad los comentarios en cada línea. Pero no tenía lo de IDA.  Voy a esta función, ahora vuelvo para atrás. Ahora voy a esta otra. Ahora dime a dónde va este  salto. Todo eso tenía que controlarse, buscar. En esta dirección de memoria, a ver. Esto está  ahí. IDA Pro divide el ensamblador en loques y te lo organiza, y ayuda mucho a ver el flujo del  programa  viendo ahí el código, el código Z80, se ve que está escribiendo un texto vertical en 1 linea.  O sea, tiene, el file map era de 32 píxeles de ancho, 32 files de ancho, que le ponemos de 8  por 8 bits, 8 por 8 píxeles, le ha dado 156 píxeles, pues está escribiendo algo en vertical.  Entonces, no estaba usando ASCII para escribir los textos. O sea, tenía su propia codificación  de que la A era el 3F, la B, el F40.  O sea, me sumaba 2 para tener la siguiente letra. Ten en cuenta que esto, en cada juego, es  enfrentarte  cada uno se inventaba ahí, pero incluso en los juegos de NeoGeo, la codificación de los textos  era ahí lo que venía en la ROM en ese momento.  Entonces una vez implementado esto, viendo que tenía que salir este texto, que era ese punto  a punto, pues sabemos que en la dirección 808004, pues ahí estaba el file map. O sea, es lo  que escribes ahí, acaba basándose al chip de files. Es otra pregunta del examen, ¿no?  Entonces ahí ya sabíamos dónde estaba el time map principal, y a partir de eso, pues ya al  menos podíamos ver textos en pantalla, al menos los textos escritos,  no se movía el file map, pero lo veíamos. Entonces a base de ver qué hacía el juego, pues fui  sacando todos los registros de dónde estaba cada cosa almacenada.  El file map, el color, los sprites, la X, la Y, si están vertidos, verticales, horizontales...  Pues esto de MAME fue relativamente rápido porque fue un par de semanas solo. Entonces el  juego ya iba, se podía jugar y tal, ya está el juego hecho. Pero, ¿qué pasaba?, que la fase de Galaxia, el juego tenía como cuatro fases en realidad, Pero  en la de Galaxia lo que pasaba era que... Bueno, pasaban dos cosas.  (1.05.34)  Una, que la nave nunca llegaba al borde y otra, que los enemigos eran infinitos.  Entonces lo que pasaba era que una EEPROM tenía un bit que se había gastado un poco.  Entonces hacía que una dirección de memoria que tenía que ser del 8000 no sé cuánto era sin  el 8000. O sea, el 8 no estaba porque ese bit se había ido.  Entonces cuando tenía que inicializar esa variable a un valor 1 aquí, no lo hacía. Entonces si  esa variable no era 1, los enemigos nunca dejaban de salir porque era algo de si estabas en  ATTRACT o no.  Además, esa variable controlaba en otro nivel si tú podías mover la nave hasta el borde de la  pantalla o no. Entonces, por un bit, el juego no se podía pasar.  te ha pasado de no ver que una rom esta corrupta???  en MAME hay una herramienta que tú la pasas a una ROM y te dice si tienes un bit que está  fijo a 1 de datos, si tienes una dirección que no va y entonces la ROM está repetida  porque falta un bit de direcciones. Entonces con esa herramienta lo pasas y al menos de  antemano te puede decir si está bien o no. Entiendo que los checks que hacían las recreativas  al encender Leían todo, leían bit a bit para ver si estaba todo bien. Luego otra cosa que se hace  también es leer la ROM varias veces, para comprobar si está dando el mismo resultado cada  vez. Porque a veces no está bien algún bit y entonces está sin hacer buen contacto en el vector  y te da valores aleatorios.  Entonces cuando ya la lectura es estable, la pasas por el ROM-CNT de este tema y te dice si  hay algún problema detectable. Bueno, la una y cuarto.  WORLD RALLY  World Rally, otro juego que la protección impidió emularlo durante muchos años.  Y al final el código del Dalas apareció por fin después de tantos años. Y ayer apareció por fin  de vuelta en mi casa. Encontró el pendrive original. Después de muchos años perdido.  la parte de que la emulación no solo es de software, Puedes llevar a un nivel de emulación  súper preciso por hardware, emular hasta el nivel de ciclos que las cosas funcionen  exactamente igual que en el original.  la fpga, Es hacer la EPROM pero en la placa entera, o sea, la placa entera metida en un chip.  Digo, quiero un Z al central. Vale, pues este chip ahora te lo programo como si fuese un Z al  central. Quiero un Z al central.  Y lo bueno es que una vez que lo has definido, pues se queda así hasta que le digas otra cosa.  Otras también funcionan con celdas de RAM. O sea, tú tienes una celda de RAM, por ejemplo,  una tabla de verdad de un AMP. Pues con una RAM de 2 por 1 bit lo puedes hacer. Porque con  las dos entradas indexas las cuatro diferentes posibilidades y tú dices  cuando los dos son cero, o sea la dirección cero, pongo cero. La dirección uno, pongo cero. La  dirección dos, pongo cero. XOR, pues esta la pongo. Cualquier tabla de verdad que se te ocurra. Entonces a base de  poner herramientas que te convierten de código a tablas de verdad y ecuaciones lógicas,  se implementan ahí.  FPGA  Actualmente, en las consolas mini de ahora, solo hay un chip principal en la placa, y ese chip  es una FPGA. Puedes meter en una FPGA varios ordenadores y una consola. No está  emulado realmente, porque hay un circuito que se comporta como el hardware original. Si la  especificación del circuito es correcta, no está emulado. Es como una emulación hardware,  pero no es emulación. Tienen mucha velocidad porque es hardware. La FPGA el límite lo pone  la capacidad.  MEGASD Y FPGA  En cuanto a FPGAs, hace unos años yo me metí en todo esto.  Entonces empecé a hacer proyectos de FPGAs(circuito integrado). Y uno de los más gordos  ahí a nivel de preservación fue este sistema que era el MegaSD.  MegaSD lo que hace es emular el CD-ROM de la Mega Drive, que ha puesto...  Entonces lo que hicimos fue emular todo el MegaSD en una FPGA. No he encontrado ningún...  Entonces... Estas consolas ahora... Las reales, 20, 30 años después, es muy difícil que  funcionen por el láser.  LEER CDS  Se te desajusta el motor, lo que mueve el láser, y ya no te lee ningún juego. O te lee unos sí y  otros no. Pero la cosa es, ¿cómo podemos leer el juego. Pues la cosa es, oye, pasamos del CD  y le ponemos algo que se crea la consola que está leyendo del CD. Haces el mismo interface.  Con la consola, con el mismo conector de la consola, respondiendo a sus señales, sus  registros, etc. Pero al otro lado, en realidad, hay un hardware, una FPGA que está simulando el  hardware original.  Todo eso se hacía por hardware en el Mega CD y luego en la FPGA.  Y ya que nos pusimos a hacer cambiar CDs, pues fuimos a la Playstation 1 también. Entonces  la Playstation 1 tiene prueba de las lentes,  porque al principio Sony hacía cosas de calidad en las primeras Playstation, pero luego  cambiaron el cristal por plástico, el calor del láser lo doblaba,  todo se desenfoca, no había manera ya de ir ajustando qué enfocarse... Solo hiciste el  programa. Entonces había uno ya, que era el PSI, pero esto lo conectabas en el bus,  y emulaba un poco lo que hicimos con el Mega, con el Mega SD. Capturaba los comandos,  hacía sus cosas y devolvía resultados. No estaba emulando el CD tal cual.  O sea, te estabas enganchando antes de que llegasen los comandos al CD.  Lo ideal sería emular el láser al nivel súper bajo de la señal analógica de los bits y los gaps del  CD, pero eso, analógico, es muy complejo.  Entonces nos enganchamos en la salida después ya del DSP, que ve uno sin fe, o sea, no lee  analógicamente bits y gaps. ¿Esto también es legado? Sí. Pero bueno, hicimos una play con un montón de cables y un analizador lógico, que era la  Capture Station.  Y ahí analizamos todas las señales que venían del CD, que ahí me parece que son 16 señales,  que es lo máximo que va a haber en el analizador lógico.  Entonces ahí había que replicar el protocolo que tiene la play con el láser.  Por ejemplo, arranca el motor, se mueve el láser un poquito hacia la derecha. Dime cuántas  pistas has atravesado mientras te vas moviendo. ¿No? ¿Tengo esta función? ¡Tac, tac, tac, tac!  Porque los CDs, mmm, igual ya no han acabado. Los CDs no tienen un direccionamiento que  tú digas, mira en el sector, 200.  No. El CD, al estar en espiral, es muy difícil calcular el tamaño de la espiral, la línea, y se pone  a ojo donde deberia estar y se lee un poco. Hay un procesador que se encarga de mover el  laser para leerlo. El laser hace un zigzag para leer algo (los bluerays tb lo usan). Además, hay  que enfocar la bobina porque no todos tienen la misma altura y no son completamente planos,  entonces hay umas bobinas que xontrolan la lente como si fuese el cristalino del ojo. Si las  bobina estan muy aretadas, esto a la larga estropea el disco.Cuando va leyendo, sabe que  pasa de una pista a otra porque hay uma pequeña linea reflectante entre ellas.  Pues todo eso hay que emularlo en una FPGA.  PROTECCION DE LA PLAYSTATION  Pues lo que hizo Sony es que, en vez de estar en espiral,  si tú lo estiras, debería ser recto. No era recto, sino que hacía así, hacía curvas. Entonces esas  curvas codificaban, hubo una serie de números de letras en el minario. O sea, detectaba ahí,  mucha curva, 1. Poca curva, 0, por ejemplo. Lo habías descubierto por ingeniería inversa. Esto  es lo que hacían los modchips de la Play, era esto. Entonces esas letras eran SCEA, Sony  Computer Entertainment America, Europa, o I, que era para Japón.  Entonces cada CD se grababa con unas letras diferentes, de forma que tú no podías jugar a los  CDs, y los americanos en las europeas, y además, un CD grabado tenía la línea en horizontal y  no daba estas letras.  Entonces los modchips lo que hacían era que se inyectaban esta señal en la señal que  detectaba el Wobble, el desfase de la línea,  porque un lector láser lleva el sensor, pero luego lleva como dos células aquí, que le ayudan a  mantenerse en la línea. Entonces si se mueve hacia arriba o hacia abajo,  estas células detectan el cambio de reflectividad y mueven la cabeza, como si fuese un misil  dirigido por calor, que va intentando buscar siempre dónde está, mantener en el centro  siempre.  Entonces este pequeño movimiento que hacía para mantenerla era lo que codificaba las letras.  El DSR vivió, como dijimos, de Dreamcast a lo que había en aquel momento. Hubo algunos  problemas porque nos dió que el disco de BOSIC toma el código. Igual había diez versiones  diferentes del código,  en el disco duro. No había SVN, ni GitHub, ni Git, ni nada. El control de versiones era un BAT  que copiaba cosas y ya está. Había archivos que faltaban, con lo cual no podíamos fácilmente  convertir, porque había que convertir de Big Endian a Little Endian. Entonces la Vita, que es una RM, es  Little Endian. Había que cambiar el orden de todos los valores de 32 y de 16 bits  en archivos de los que no teníamos el fuente. Decimos herramientas que analizan, que iban  atravesando la estructura de datos para ir dándole la vuelta a todos los bytes.  rollback: dos máquinas van jugando pero se van mandando las teclas, entonces si no tienes  teclas, intentas estimar que va a hacer el otro, y cuando te llega la tecla del otro pues entonces  ves si te has equivocado y si lo has hecho mal vuelves atras a la última tecla que le has dado y  emulas en un frame hacia adelante como si esa tecla se hubiese pulsado. Corrijo mi error en el  pasado. es como en el gps cuando pierde conexión con el satélite y cuando recupera vuelve  hacia atrás porque el dato se ha llegado tarde y ya lo había pintado.  lag negativo: calcular todas las posibilidades y me dicen cual es y como tarda 1 frame desde  que pulso el boton hasta que hace la accion y ya he hecho todas las posibilidades de tocar los  botones pues eso se puede  ser fiel en el timing en emulación: con una fpga se han conseguido timings que fuesen igual  que en la original. 